{"version":3,"file":"markerclustererplus.min.js","sources":["../src/overlay-view-safe.ts","../src/cluster-icon.ts","../src/cluster.ts","../src/markerclusterer.ts"],"sourcesContent":["/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  for (const property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This class represents the object for values in the `styles` array passed\n * to the {@link MarkerClusterer} constructor. The element in this array that is used to\n * style the cluster icon is determined by calling the `calculator` function.\n */\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\n/**\n *\n * @hidden\n */\nfunction toCssText(styles: { [key: string]: string }): string {\n  return Object.keys(styles)\n    .reduce((acc, key) => {\n      if (styles[key]) {\n        acc.push(key + \":\" + styles[key]);\n      }\n      return acc;\n    }, [])\n    .join(\";\");\n}\n\n/**\n *\n * @hidden\n */\nfunction coercePixels(pixels: number): string {\n  return pixels ? pixels + \"px\" : undefined;\n}\n\nexport interface ClusterIconStyle {\n  /** The URL of the cluster icon image file. If not set, img element will not be created */\n  url?: string;\n  /** The name of the CSS class defining styles for the cluster markers. */\n  className?: string;\n  /** Height The display height (in pixels) of the cluster icon. Required. */\n  height: number;\n  /** Width The display width (in pixels) of the cluster icon. Required. */\n  width: number;\n  /**\n   * The position (in pixels) from the center of the cluster icon to\n   * where the text label is to be centered and drawn. The format is `[yoffset, xoffset]`\n   * where `yoffset` increases as you go down from center and `xoffset`\n   * increases to the right of center. The default is `[0, 0]`.\n   */\n  anchorText?: [number, number];\n  /**\n   * The anchor position (in pixels) of the cluster icon. This is the\n   * spot on the cluster icon that is to be aligned with the cluster position. The format is\n   * `[yoffset, xoffset]` where `yoffset` increases as you go down and\n   * `xoffset` increases to the right of the top-left corner of the icon. The default\n   * anchor position is the center of the cluster icon.\n   */\n  anchorIcon?: [number, number];\n  /**\n   * The color of the label text shown on the cluster icon.\n   * @default `\"black\"`\n   */\n  textColor?: string;\n  /** The size (in pixels) of the label text shown on the cluster icon.\n   * @default `11`\n   */\n  textSize?: number;\n\n  /** The line height (in pixels) of the label text shown on the cluster icon.\n   * @default the same as cluster icon height\n   */\n  textLineHeight?: number;\n  /**\n   * The value of the CSS `text-decoration`\n   * property for the label text shown on the cluster icon.\n   *\n   * @default `\"none\"`\n   */\n  textDecoration?: string;\n  /**\n   * The value of the CSS `font-weight`\n   * property for the label text shown on the cluster icon.\n   *\n   *  @default `\"bold\"`\n   */\n  fontWeight?: string;\n  /**\n   *  The value of the CSS `font-style`\n   *  property for the label text shown on the cluster icon.\n   *\n   *  @default `\"normal\"`\n   */\n  fontStyle?: string;\n  /**\n   *  The value of the CSS `font-family`\n   *  property for the label text shown on the cluster icon.\n   *  @default `\"Arial,sans-serif\"`\n   */\n  fontFamily?: string;\n  /**\n   * The position of the cluster icon image\n   * within the image defined by `url`. The format is `\"xpos ypos\"`\n   * (the same format as for the CSS `background-position` property). You must set\n   * this property appropriately when the image defined by `url` represents a sprite\n   * containing multiple images. Note that the position <i>must</i> be specified in px units.\n   *\n   * @default `\"0 0\"`\n   */\n  backgroundPosition?: string;\n}\n\n/**\n * @description This is an object containing general information about a cluster icon. This is\n *  the object that a `calculator` function returns.\n */\nexport interface ClusterIconInfo {\n  /**\n   * The text of the label to be shown on the cluster icon.\n   */\n  text: string;\n  /**\n   * The index plus 1 of the element in the `styles`\n   */\n  index: number;\n  /**\n   * The tooltip to display when the mouse moves over the cluster icon.\n   * If this value is `undefined` or `\"\"`, `title` is set to the\n   * value of the `title` property passed to the MarkerClusterer.\n   */\n  title: string;\n}\n\n/**\n * A cluster icon.\n */\nexport class ClusterIcon extends OverlayViewSafe {\n  private className_: string;\n  private center_: google.maps.LatLng = null;\n  private div_: HTMLDivElement = null;\n  private sums_: ClusterIconInfo = null;\n  private visible_ = false;\n\n  private style: ClusterIconStyle = null;\n\n  private anchorText_: [number, number];\n  private anchorIcon_: [number, number];\n\n  private boundsChangedListener_: google.maps.MapsEventListener;\n\n  /**\n   * @param cluster_ The cluster with which the icon is to be associated.\n   * @param styles_ An array of {@link ClusterIconStyle} defining the cluster icons\n   *  to use for various cluster sizes.\n   */\n  constructor(private cluster_: Cluster, private styles_: ClusterIconStyle[]) {\n    super();\n\n    this.setMap(cluster_.getMap()); // Note: this causes onAdd to be called\n  }\n\n  /**\n   * Adds the icon to the DOM.\n   */\n  onAdd(): void {\n    let cMouseDownInCluster: boolean;\n    let cDraggingMapByCluster: boolean;\n\n    const mc = this.cluster_.getMarkerClusterer();\n\n    const [major, minor] = google.maps.version.split(\".\");\n\n    const gmVersion = parseInt(major, 10) * 100 + parseInt(minor, 10);\n\n    this.div_ = document.createElement(\"div\");\n    if (this.visible_) {\n      this.show();\n    }\n\n    this.getPanes().overlayMouseTarget.appendChild(this.div_);\n\n    // Fix for Issue 157\n    this.boundsChangedListener_ = google.maps.event.addListener(\n      this.getMap(),\n      \"bounds_changed\",\n      function() {\n        cDraggingMapByCluster = cMouseDownInCluster;\n      }\n    );\n\n    google.maps.event.addDomListener(this.div_, \"mousedown\", () => {\n      cMouseDownInCluster = true;\n      cDraggingMapByCluster = false;\n    });\n\n    // March 1, 2018: Fix for this 3.32 exp bug, https://issuetracker.google.com/issues/73571522\n    // But it doesn't work with earlier releases so do a version check.\n    if (gmVersion >= 332) {\n      // Ugly version-dependent code\n      google.maps.event.addDomListener(this.div_, \"touchstart\", e => {\n        e.stopPropagation();\n      });\n    }\n\n    google.maps.event.addDomListener(this.div_, \"click\", e => {\n      cMouseDownInCluster = false;\n      if (!cDraggingMapByCluster) {\n        /**\n         * This event is fired when a cluster marker is clicked.\n         * @name MarkerClusterer#click\n         * @param {Cluster} c The cluster that was clicked.\n         * @event\n         */\n        google.maps.event.trigger(mc, \"click\", this.cluster_);\n        google.maps.event.trigger(mc, \"clusterclick\", this.cluster_); // deprecated name\n\n        // The default click handler follows. Disable it by setting\n        // the zoomOnClick property to false.\n        if (mc.getZoomOnClick()) {\n          // Zoom into the cluster.\n          const mz = mc.getMaxZoom();\n          const theBounds = this.cluster_.getBounds();\n          (mc.getMap() as google.maps.Map).fitBounds(theBounds);\n          // There is a fix for Issue 170 here:\n          setTimeout(function() {\n            (mc.getMap() as google.maps.Map).fitBounds(theBounds);\n            // Don't zoom beyond the max zoom level\n            if (mz !== null && mc.getMap().getZoom() > mz) {\n              mc.getMap().setZoom(mz + 1);\n            }\n          }, 100);\n        }\n\n        // Prevent event propagation to the map:\n        e.cancelBubble = true;\n        if (e.stopPropagation) {\n          e.stopPropagation();\n        }\n      }\n    });\n\n    google.maps.event.addDomListener(this.div_, \"mouseover\", () => {\n      /**\n       * This event is fired when the mouse moves over a cluster marker.\n       * @name MarkerClusterer#mouseover\n       * @param {Cluster} c The cluster that the mouse moved over.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"mouseover\", this.cluster_);\n    });\n\n    google.maps.event.addDomListener(this.div_, \"mouseout\", () => {\n      /**\n       * This event is fired when the mouse moves out of a cluster marker.\n       * @name MarkerClusterer#mouseout\n       * @param {Cluster} c The cluster that the mouse moved out of.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"mouseout\", this.cluster_);\n    });\n  }\n\n  /**\n   * Removes the icon from the DOM.\n   */\n  onRemove(): void {\n    if (this.div_ && this.div_.parentNode) {\n      this.hide();\n      google.maps.event.removeListener(this.boundsChangedListener_);\n      google.maps.event.clearInstanceListeners(this.div_);\n      this.div_.parentNode.removeChild(this.div_);\n      this.div_ = null;\n    }\n  }\n\n  /**\n   * Draws the icon.\n   */\n  draw(): void {\n    if (this.visible_) {\n      const pos = this.getPosFromLatLng_(this.center_);\n      this.div_.style.top = pos.y + \"px\";\n      this.div_.style.left = pos.x + \"px\";\n    }\n  }\n\n  /**\n   * Hides the icon.\n   */\n  hide(): void {\n    if (this.div_) {\n      this.div_.style.display = \"none\";\n    }\n    this.visible_ = false;\n  }\n\n  /**\n   * Positions and shows the icon.\n   */\n  show(): void {\n    if (this.div_) {\n      this.div_.className = this.className_;\n      this.div_.style.cssText = this.createCss_(\n        this.getPosFromLatLng_(this.center_)\n      );\n\n      this.div_.innerHTML =\n        (this.style.url ? this.getImageElementHtml() : \"\") +\n        this.getLabelDivHtml();\n\n      if (typeof this.sums_.title === \"undefined\" || this.sums_.title === \"\") {\n        this.div_.title = this.cluster_.getMarkerClusterer().getTitle();\n      } else {\n        this.div_.title = this.sums_.title;\n      }\n      this.div_.style.display = \"\";\n    }\n    this.visible_ = true;\n  }\n\n  private getLabelDivHtml(): string {\n    const mc = this.cluster_.getMarkerClusterer();\n    const ariaLabel = mc.ariaLabelFn(this.sums_.text);\n\n    const divStyle: { [key: string]: string } = {\n      position: \"absolute\",\n      top: coercePixels(this.anchorText_[0]),\n      left: coercePixels(this.anchorText_[1]),\n      color: this.style.textColor,\n      \"font-size\": coercePixels(this.style.textSize),\n      \"font-family\": this.style.fontFamily,\n      \"font-weight\": this.style.fontWeight,\n      \"font-style\": this.style.fontStyle,\n      \"text-decoration\": this.style.textDecoration,\n      \"text-align\": \"center\",\n      width: coercePixels(this.style.width),\n      \"line-height\": coercePixels(this.style.textLineHeight)\n    };\n\n    return `\n<div aria-label=\"${ariaLabel}\" style=\"${toCssText(divStyle)}\" tabindex=\"0\">\n  <span aria-hidden=\"true\">${this.sums_.text}</span>\n</div>\n`;\n  }\n\n  private getImageElementHtml(): string {\n    // NOTE: values must be specified in px units\n    const bp = (this.style.backgroundPosition || \"0 0\").split(\" \");\n    const spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    const spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, \"\"), 10);\n\n    let dimensions: { [key: string]: string } = {};\n\n    if (this.cluster_.getMarkerClusterer().getEnableRetinaIcons()) {\n      dimensions = {\n        width: coercePixels(this.style.width),\n        height: coercePixels(this.style.height)\n      };\n    } else {\n      const [Y1, X1, Y2, X2] = [\n        -1 * spriteV,\n        -1 * spriteH + this.style.width,\n        -1 * spriteV + this.style.height,\n        -1 * spriteH\n      ];\n      dimensions = {\n        clip: `rect(${Y1}px, ${X1}px, ${Y2}px, ${X2}px)`\n      };\n    }\n\n    const cssText = toCssText({\n      position: \"absolute\",\n      top: coercePixels(spriteV),\n      left: coercePixels(spriteH),\n      ...dimensions\n    });\n\n    return `<img alt=\"${this.sums_.text}\" aria-hidden=\"true\" src=\"${this.style.url}\" style=\"${cssText}\"/>`;\n  }\n\n  /**\n   * Sets the icon styles to the appropriate element in the styles array.\n   *\n   * @ignore\n   * @param sums The icon label text and styles index.\n   */\n  useStyle(sums: ClusterIconInfo): void {\n    this.sums_ = sums;\n    let index = Math.max(0, sums.index - 1);\n    index = Math.min(this.styles_.length - 1, index);\n    this.style = this.styles_[index];\n\n    this.anchorText_ = this.style.anchorText || [0, 0];\n    this.anchorIcon_ = this.style.anchorIcon || [\n      Math.floor(this.style.height / 2),\n      Math.floor(this.style.width / 2)\n    ];\n\n    this.className_ =\n      this.cluster_.getMarkerClusterer().getClusterClass() +\n      \" \" +\n      (this.style.className || \"cluster-\" + index);\n  }\n\n  /**\n   * Sets the position at which to center the icon.\n   *\n   * @param center The latlng to set as the center.\n   */\n  setCenter(center: google.maps.LatLng): void {\n    this.center_ = center;\n  }\n\n  /**\n   * Creates the `cssText` style parameter based on the position of the icon.\n   *\n   * @param pos The position of the icon.\n   * @return The CSS style text.\n   */\n  private createCss_(pos: google.maps.Point): string {\n    return toCssText({\n      \"z-index\": `${this.cluster_.getMarkerClusterer().getZIndex()}`,\n      top: coercePixels(pos.y),\n      left: coercePixels(pos.x),\n      width: coercePixels(this.style.width),\n      height: coercePixels(this.style.height),\n      cursor: \"pointer\",\n      position: \"absolute\",\n      \"-webkit-user-select\": \"none\",\n      \"-khtml-user-select\": \"none\",\n      \"-moz-user-select\": \"none\",\n      \"-o-user-select\": \"none\",\n      \"user-select\": \"none\"\n    });\n  }\n\n  /**\n   * Returns the position at which to place the DIV depending on the latlng.\n   *\n   * @param latlng The position in latlng.\n   * @return The position in pixels.\n   */\n  private getPosFromLatLng_(latlng: google.maps.LatLng): google.maps.Point {\n    const pos = this.getProjection().fromLatLngToDivPixel(latlng);\n    pos.x = Math.floor(pos.x - this.anchorIcon_[1]);\n    pos.y = Math.floor(pos.y - this.anchorIcon_[0]);\n    return pos;\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MarkerClusterer, ClusterAugmentedMarker } from \"./markerclusterer\";\nimport { ClusterIcon } from \"./cluster-icon\";\n\n/**\n * Creates a single cluster that manages a group of proximate markers.\n *  Used internally, do not call this constructor directly.\n */\nexport class Cluster {\n  private map_ = this.markerClusterer_.getMap() as google.maps.Map;\n  private minClusterSize_: number = this.markerClusterer_.getMinimumClusterSize();\n  private averageCenter_: boolean = this.markerClusterer_.getAverageCenter();\n  private markers_: ClusterAugmentedMarker[] = []; // TODO: type;\n  private center_: google.maps.LatLng = null;\n  private bounds_: google.maps.LatLngBounds = null;\n  private clusterIcon_ = new ClusterIcon(\n    this,\n    this.markerClusterer_.getStyles()\n  );\n\n  /**\n   *\n   * @param markerClusterer_ The `MarkerClusterer` object with which this\n   *  cluster is associated.\n   */\n  constructor(private markerClusterer_: MarkerClusterer) {}\n\n  /**\n   * Returns the number of markers managed by the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\n   *\n   * @return The number of markers in the cluster.\n   */\n  public getSize(): number {\n    return this.markers_.length;\n  }\n\n  /**\n   * Returns the array of markers managed by the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\n   *\n   * @return The array of markers in the cluster.\n   */\n  public getMarkers(): google.maps.Marker[] {\n    return this.markers_;\n  }\n\n  /**\n   * Returns the center of the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler\n   * for the `MarkerClusterer` object.\n   *\n   * @return The center of the cluster.\n   */\n  public getCenter(): google.maps.LatLng {\n    return this.center_;\n  }\n\n  /**\n   * Returns the map with which the cluster is associated.\n   *\n   * @return The map.\n   * @ignore\n   */\n  public getMap(): google.maps.Map {\n    return this.map_;\n  }\n\n  /**\n   * Returns the `MarkerClusterer` object with which the cluster is associated.\n   *\n   * @return The associated marker clusterer.\n   * @ignore\n   */\n  public getMarkerClusterer(): MarkerClusterer {\n    return this.markerClusterer_;\n  }\n\n  /**\n   * Returns the bounds of the cluster.\n   *\n   * @return the cluster bounds.\n   * @ignore\n   */\n  public getBounds(): google.maps.LatLngBounds {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    const markers = this.getMarkers();\n    for (let i = 0; i < markers.length; i++) {\n      bounds.extend(markers[i].getPosition());\n    }\n    return bounds;\n  }\n\n  /**\n   * Removes the cluster from the map.\n   *\n   * @ignore\n   */\n  public remove(): void {\n    this.clusterIcon_.setMap(null);\n    this.markers_ = [];\n    delete this.markers_;\n  }\n\n  /**\n   * Adds a marker to the cluster.\n   *\n   * @param marker The marker to be added.\n   * @return True if the marker was added.\n   * @ignore\n   */\n  public addMarker(\n    marker: google.maps.Marker & { isAdded?: boolean }\n  ): boolean {\n    if (this.isMarkerAlreadyAdded_(marker)) {\n      return false;\n    }\n\n    if (!this.center_) {\n      this.center_ = marker.getPosition();\n      this.calculateBounds_();\n    } else {\n      if (this.averageCenter_) {\n        const l = this.markers_.length + 1;\n        const lat =\n          (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n        const lng =\n          (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n        this.center_ = new google.maps.LatLng(lat, lng);\n        this.calculateBounds_();\n      }\n    }\n\n    marker.isAdded = true;\n    this.markers_.push(marker);\n\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n    if (mz !== null && this.map_.getZoom() > mz) {\n      // Zoomed in past max zoom, so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount < this.minClusterSize_) {\n      // Min cluster size not reached so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount === this.minClusterSize_) {\n      // Hide the markers that were showing.\n      for (let i = 0; i < mCount; i++) {\n        this.markers_[i].setMap(null);\n      }\n    } else {\n      marker.setMap(null);\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines if a marker lies within the cluster's bounds.\n   *\n   * @param marker The marker to check.\n   * @return True if the marker lies in the bounds.\n   * @ignore\n   */\n  public isMarkerInClusterBounds(marker: google.maps.Marker): boolean {\n    return this.bounds_.contains(marker.getPosition());\n  }\n\n  /**\n   * Calculates the extended bounds of the cluster with the grid.\n   */\n  private calculateBounds_(): void {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n  }\n\n  /**\n   * Updates the cluster icon.\n   */\n  public updateIcon(): void {\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n\n    if (mz !== null && this.map_.getZoom() > mz) {\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    if (mCount < this.minClusterSize_) {\n      // Min cluster size not yet reached.\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    const numStyles = this.markerClusterer_.getStyles().length;\n    const sums = this.markerClusterer_.getCalculator()(\n      this.markers_,\n      numStyles\n    );\n    this.clusterIcon_.setCenter(this.center_);\n    this.clusterIcon_.useStyle(sums);\n    this.clusterIcon_.show();\n  }\n\n  /**\n   * Determines if a marker has already been added to the cluster.\n   *\n   * @param marker The marker to check.\n   * @return True if the marker has already been added.\n   */\n  private isMarkerAlreadyAdded_(marker: google.maps.Marker): boolean {\n    if (this.markers_.indexOf) {\n      return this.markers_.indexOf(marker) !== -1;\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @name MarkerClustererPlus for Google Maps V3\n * @author Gary Little\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of markers.\n * <p>\n * This is an enhanced V3 implementation of the V2 MarkerClusterer by Xiaoxi Wu. It is\n * based on the V3 MarkerClusterer port by Luke Mahe. MarkerClustererPlus was created\n * by Gary Little.\n * <p>\n * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It\n *  adds support for the `ignoreHidden`, `title`, `batchSizeIE`,\n *  and `calculator` properties as well as support for four more events. It also allows\n *  greater control over the styling of the text that appears on the cluster marker. The\n *  documentation has been significantly improved and the overall code has been simplified and\n *  polished. Very large numbers of markers can now be managed without causing Javascript timeout\n *  errors on Internet Explorer. Note that the name of the `clusterclick` event has been\n *  deprecated. The new name is `click`, so please change your application code now.\n */\n\nimport { Cluster } from \"./cluster\";\nimport { ClusterIconInfo, ClusterIconStyle } from \"./cluster-icon\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\n/**\n * @param text The text attribute of the cluster\n */\ntype AriaLabelFn = (text: string) => string;\n\nexport type Calculator = (\n  markers: google.maps.Marker[],\n  clusterIconStylesCount: number\n) => ClusterIconInfo;\n\nexport interface ClusterAugmentedMarker extends google.maps.Marker {\n  isAdded?: boolean;\n}\n\n/**\n * This event is fired on the {@link MarkerClusterer} instance when the `MarkerClusterer` stops clustering markers.\n *\n * Example:\n * ```typescript\n *  mc.addListener('clusteringend', (mc: MarkerClusterer) => {})\n * ```\n *\n * @param mc The MarkerClusterer whose markers are being clustered.\n * @event clusteringend\n */\nexport declare function clusteringend(mc: MarkerClusterer): void;\n\n/**\n * This event is fired on the {@link MarkerClusterer} instance when the `MarkerClusterer` begins clustering markers.\n *\n * Example:\n * ```typescript\n *  mc.addListener('clusteringbegin', (mc: MarkerClusterer) => {})\n * ```\n *\n * @param mc The MarkerClusterer whose markers are being clustered.\n * @event clusteringbegin\n */\nexport declare function clusteringbegin(mc: MarkerClusterer): void;\n\n/**\n * Optional parameter passed to the {@link MarkerClusterer} constructor.\n */\nexport interface MarkerClustererOptions {\n  /**\n   * The grid size of a cluster in pixels. The grid is a square.\n   *\n   * @default `60`\n   */\n  gridSize?: number;\n  /**\n   * The maximum zoom level at which clustering is enabled or\n   * `null` if clustering is to be enabled at all zoom levels.\n   *\n   * @default `null`\n   */\n  maxZoom?: number;\n\n  /**\n   * Whether to zoom the map when a cluster marker is\n   * clicked. You may want to set this to `false` if you have installed a handler\n   * for the `click` event and it deals with zooming on its own.\n   *\n   * @default `true`\n   */\n  zoomOnClick?: boolean;\n  /***\n   * Whether the position of a cluster marker should be\n   * the average position of all markers in the cluster. If set to `false`, the\n   * cluster marker is positioned at the location of the first marker added to the cluster.\n   *\n   * @default `false`\n   */\n  averageCenter?: boolean;\n  /**\n   * The minimum number of markers needed in a cluster\n   * before the markers are hidden and a cluster marker appears.\n   *\n   * @default `2`\n   */\n  minimumClusterSize?: number;\n\n  /**\n   *  the z-index of a cluster.\n   *\n   *  @default `google.maps.Marker.MAX_ZINDEX + 1`\n   */\n  zIndex?: number;\n\n  /**\n   * Whether to ignore hidden markers in clusters. You\n   * may want to set this to `true` to ensure that hidden markers are not included\n   * in the marker count that appears on a cluster marker (this count is the value of the\n   * `text` property of the result returned by the default  {@link calculator}).\n   * If set to `true` and you change the visibility of a marker being clustered, be\n   * sure to also call {@link MarkerClusterer#repaint()}.\n   *\n   * @default `false`\n   */\n  ignoreHidden?: boolean;\n  /**\n   * The tooltip to display when the mouse moves over a cluster\n   * marker. (Alternatively, you can use a custom `calculator` function to specify a\n   * different tooltip for each cluster marker.)\n   *\n   * @default `\"\"`\n   */\n  title?: string;\n  /**\n   * The function used to determine\n   * the text to be displayed on a cluster marker and the index indicating which style to use\n   * for the cluster marker. The input parameters for the function are (1) the array of markers\n   * represented by a cluster marker and (2) the number of cluster icon styles. It returns a\n   * {@link ClusterIconInfo} object. The default `calculator` returns a\n   * `text` property which is the number of markers in the cluster and an\n   * `index` property which is one higher than the lowest integer such that\n   * `10^i` exceeds the number of markers in the cluster, or the size of the styles\n   * array, whichever is less. The `styles` array element used has an index of\n   * `index` minus 1. For example, the default `calculator` returns a\n   * `text` value of `\"125\"` and an `index` of `3`\n   * for a cluster icon representing 125 markers so the element used in the `styles`\n   * array is `2`. A `calculator` may also return a `title`\n   * property that contains the text of the tooltip to be used for the cluster marker. If\n   * `title` is not defined, the tooltip is set to the value of the `title`\n   * property for the MarkerClusterer.\n   *\n   * @default {@link MarkerClusterer.CALCULATOR}\n   */\n  calculator?: Calculator;\n  /**\n   * The name of the CSS class defining general styles\n   * for the cluster markers. Use this class to define CSS styles that are not set up by the code\n   * that processes the `styles` array.\n   *\n   * @default `\"cluster\"`\n   */\n  clusterClass?: string;\n  /**\n   * An array of {@link ClusterIconStyle} elements defining the styles\n   * of the cluster markers to be used. The element to be used to style a given cluster marker\n   * is determined by the function defined by the `calculator` property.\n   * The default is an array of {@link ClusterIconStyle} elements whose properties are derived\n   * from the values for `imagePath`, `imageExtension`, and `imageSizes`.\n   *\n   * @default `styles`\n   */\n  styles?: ClusterIconStyle[];\n  /**\n   * Whether to allow the use of cluster icons that\n   * have sizes that are some multiple (typically double) of their actual display size. Icons such\n   * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.\n   * Note: if this property is `true`, sprites cannot be used as cluster icons.\n   *\n   * @default `false`\n   */\n  enableRetinaIcons?: boolean;\n  /**\n   * Set this property to the number of markers to be processed in a single batch when using\n   * a browser other than Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).\n   *\n   * @default `MarkerClusterer.BATCH_SIZE`\n   */\n  batchSize?: number;\n  /**\n   * When Internet Explorer is\n   * being used, markers are processed in several batches with a small delay inserted between\n   * each batch in an attempt to avoid Javascript timeout errors. Set this property to the\n   * number of markers to be processed in a single batch; select as high a number as you can\n   * without causing a timeout error in the browser. This number might need to be as low as 100\n   * if 15,000 markers are being managed, for example.\n   *\n   * @default `MarkerClusterer.BATCH_SIZE_IE`\n   */\n  batchSizeIE?: number;\n  /**\n   * The full URL of the root name of the group of image files to use for cluster icons.\n   * The complete file name is of the form `imagePath`n.`imageExtension`\n   * where n is the image file number (1, 2, etc.).\n   *\n   * @default `MarkerClusterer.IMAGE_PATH`\n   */\n  imagePath?: string;\n  /**\n   * The extension name for the cluster icon image files (e.g., `\"png\"` or\n   * `\"jpg\"`).\n   *\n   * @default `MarkerClusterer.IMAGE_EXTENSION`\n   */\n  imageExtension?: string;\n  /**\n   * An array of numbers containing the widths of the group of\n   * `imagePath`n.`imageExtension` image files.\n   * (The images are assumed to be square.)\n   *\n   * @default `MarkerClusterer.IMAGE_SIZES`\n   */\n  imageSizes?: number[];\n  /**\n   * A function to take the text attribute associated with the cluster and output a string to attach an\n   * ariaLabel to the cluster\n   */\n  ariaLabelFn?: AriaLabelFn;\n}\n\n/**\n * @ignore\n */\nconst getOption = <T, K extends keyof T>(\n  options: T,\n  prop: K,\n  def: T[K]\n): T[K] => {\n  if (options[prop] !== undefined) {\n    return options[prop];\n  } else {\n    return def;\n  }\n};\n\nexport class MarkerClusterer extends OverlayViewSafe {\n  /**\n   * The number of markers to process in one batch.\n   */\n  static BATCH_SIZE = 2000;\n\n  /**\n   * The number of markers to process in one batch (IE only).\n   */\n  static BATCH_SIZE_IE = 500;\n\n  /**\n   * The default root name for the marker cluster images.\n   */\n  static IMAGE_PATH = \"../images/m\";\n\n  /**\n   * The default extension name for the marker cluster images.\n   */\n  static IMAGE_EXTENSION = \"png\";\n\n  /**\n   * The default array of sizes for the marker cluster images.\n   */\n  static IMAGE_SIZES: number[] = [53, 56, 66, 78, 90];\n\n  private markers_: ClusterAugmentedMarker[] = [];\n  private clusters_: Cluster[] = [];\n  private listeners_: google.maps.MapsEventListener[] = [];\n\n  private activeMap_: google.maps.Map = null;\n  private ready_ = false;\n\n  public ariaLabelFn = this.options.ariaLabelFn || ((): string => \"\");\n\n  private zIndex_ = this.options.zIndex || google.maps.Marker.MAX_ZINDEX + 1;\n  private gridSize_ = this.options.gridSize || 60;\n  private minClusterSize_ = this.options.minimumClusterSize || 2;\n  private maxZoom_ = this.options.maxZoom || null;\n  private styles_: ClusterIconStyle[] = this.options.styles || [];\n  private title_ = this.options.title || \"\";\n\n  private zoomOnClick_ = getOption(this.options, \"zoomOnClick\", true);\n  private averageCenter_ = getOption(this.options, \"averageCenter\", false);\n\n  private ignoreHidden_ = getOption(this.options, \"ignoreHidden\", false);\n  private enableRetinaIcons_ = getOption(\n    this.options,\n    \"enableRetinaIcons\",\n    false\n  );\n\n  private imagePath_ = this.options.imagePath || MarkerClusterer.IMAGE_PATH;\n  private imageExtension_ =\n    this.options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;\n  private imageSizes_ = this.options.imageSizes || MarkerClusterer.IMAGE_SIZES;\n  private calculator_ = this.options.calculator || MarkerClusterer.CALCULATOR;\n  private batchSize_ = this.options.batchSize || MarkerClusterer.BATCH_SIZE;\n  private batchSizeIE_ =\n    this.options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;\n  private clusterClass_ = this.options.clusterClass || \"cluster\";\n\n  private prevZoom_: number;\n  private timerRefStatic: number;\n\n  /**\n   * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.\n   * @param map The Google map to attach to.\n   * @param markers The markers to be added to the cluster.\n   * @param options The optional parameters.\n   */\n  constructor(\n    map: google.maps.Map,\n    markers: google.maps.Marker[] = [],\n    private options: MarkerClustererOptions = {}\n  ) {\n    super();\n\n    if (navigator.userAgent.toLowerCase().indexOf(\"msie\") !== -1) {\n      // Try to avoid IE timeout when processing a huge number of markers:\n      this.batchSize_ = this.batchSizeIE_;\n    }\n\n    this.setupStyles_();\n\n    this.addMarkers(markers, true);\n    this.setMap(map); // Note: this causes onAdd to be called\n  }\n\n  /**\n   * Implementation of the onAdd interface method.\n   * @ignore\n   */\n  onAdd(): void {\n    this.activeMap_ = this.getMap() as google.maps.Map;\n    this.ready_ = true;\n\n    this.repaint();\n\n    this.prevZoom_ = this.getMap().getZoom();\n\n    // Add the map event listeners\n    this.listeners_ = [\n      google.maps.event.addListener(this.getMap(), \"zoom_changed\", () => {\n        const map: google.maps.Map & {\n          minZoom: number;\n          maxZoom: number;\n          mapTypes: { [type: string]: google.maps.MapType };\n        } = this.getMap() as any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        // Fix for bug #407\n        // Determines map type and prevents illegal zoom levels\n        const minZoom = map.minZoom || 0;\n        const maxZoom = Math.min(\n          map.maxZoom || 100,\n          map.mapTypes[map.getMapTypeId()].maxZoom\n        );\n        const zoom = Math.min(\n          Math.max(this.getMap().getZoom(), minZoom),\n          maxZoom\n        );\n\n        if (this.prevZoom_ != zoom) {\n          this.prevZoom_ = zoom;\n          this.resetViewport_(false);\n        }\n      }),\n      google.maps.event.addListener(this.getMap(), \"idle\", () => {\n        this.redraw_();\n      })\n    ];\n  }\n\n  /**\n   * Implementation of the onRemove interface method.\n   * Removes map event listeners and all cluster icons from the DOM.\n   * All managed markers are also put back on the map.\n   * @ignore\n   */\n  onRemove(): void {\n    // Put all the managed markers back on the map:\n    for (let i = 0; i < this.markers_.length; i++) {\n      if (this.markers_[i].getMap() !== this.activeMap_) {\n        this.markers_[i].setMap(this.activeMap_);\n      }\n    }\n\n    // Remove all clusters:\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n    this.clusters_ = [];\n\n    // Remove map event listeners:\n    for (let i = 0; i < this.listeners_.length; i++) {\n      google.maps.event.removeListener(this.listeners_[i]);\n    }\n    this.listeners_ = [];\n\n    this.activeMap_ = null;\n    this.ready_ = false;\n  }\n\n  /**\n   * Implementation of the draw interface method.\n   * @ignore\n   */\n  draw(): void {}\n\n  /**\n   * Sets up the styles object.\n   */\n  private setupStyles_(): void {\n    if (this.styles_.length > 0) {\n      return;\n    }\n\n    for (let i = 0; i < this.imageSizes_.length; i++) {\n      const size = this.imageSizes_[i];\n      this.styles_.push(\n        MarkerClusterer.withDefaultStyle({\n          url: this.imagePath_ + (i + 1) + \".\" + this.imageExtension_,\n          height: size,\n          width: size\n        })\n      );\n    }\n  }\n\n  /**\n   *  Fits the map to the bounds of the markers managed by the clusterer.\n   */\n  fitMapToMarkers(): void {\n    const markers = this.getMarkers();\n    const bounds = new google.maps.LatLngBounds();\n    for (let i = 0; i < markers.length; i++) {\n      // March 3, 2018: Bug fix -- honor the ignoreHidden property\n      if (markers[i].getVisible() || !this.getIgnoreHidden()) {\n        bounds.extend(markers[i].getPosition());\n      }\n    }\n\n    (this.getMap() as google.maps.Map).fitBounds(bounds);\n  }\n\n  /**\n   * Returns the value of the `gridSize` property.\n   *\n   * @return The grid size.\n   */\n  getGridSize(): number {\n    return this.gridSize_;\n  }\n\n  /**\n   * Sets the value of the `gridSize` property.\n   *\n   * @param gridSize The grid size.\n   */\n  setGridSize(gridSize: number): void {\n    this.gridSize_ = gridSize;\n  }\n\n  /**\n   * Returns the value of the `minimumClusterSize` property.\n   *\n   * @return The minimum cluster size.\n   */\n  getMinimumClusterSize(): number {\n    return this.minClusterSize_;\n  }\n\n  /**\n   * Sets the value of the `minimumClusterSize` property.\n   *\n   * @param minimumClusterSize The minimum cluster size.\n   */\n  setMinimumClusterSize(minimumClusterSize: number): void {\n    this.minClusterSize_ = minimumClusterSize;\n  }\n\n  /**\n   *  Returns the value of the `maxZoom` property.\n   *\n   *  @return The maximum zoom level.\n   */\n  getMaxZoom(): number {\n    return this.maxZoom_;\n  }\n\n  /**\n   *  Sets the value of the `maxZoom` property.\n   *\n   *  @param maxZoom The maximum zoom level.\n   */\n  setMaxZoom(maxZoom: number): void {\n    this.maxZoom_ = maxZoom;\n  }\n\n  getZIndex(): number {\n    return this.zIndex_;\n  }\n\n  setZIndex(zIndex: number): void {\n    this.zIndex_ = zIndex;\n  }\n\n  /**\n   *  Returns the value of the `styles` property.\n   *\n   *  @return The array of styles defining the cluster markers to be used.\n   */\n  getStyles(): ClusterIconStyle[] {\n    return this.styles_;\n  }\n\n  /**\n   *  Sets the value of the `styles` property.\n   *\n   *  @param styles The array of styles to use.\n   */\n  setStyles(styles: ClusterIconStyle[]): void {\n    this.styles_ = styles;\n  }\n\n  /**\n   * Returns the value of the `title` property.\n   *\n   * @return The content of the title text.\n   */\n  getTitle(): string {\n    return this.title_;\n  }\n\n  /**\n   *  Sets the value of the `title` property.\n   *\n   *  @param title The value of the title property.\n   */\n  setTitle(title: string): void {\n    this.title_ = title;\n  }\n\n  /**\n   * Returns the value of the `zoomOnClick` property.\n   *\n   * @return True if zoomOnClick property is set.\n   */\n  getZoomOnClick(): boolean {\n    return this.zoomOnClick_;\n  }\n\n  /**\n   *  Sets the value of the `zoomOnClick` property.\n   *\n   *  @param zoomOnClick The value of the zoomOnClick property.\n   */\n  setZoomOnClick(zoomOnClick: boolean): void {\n    this.zoomOnClick_ = zoomOnClick;\n  }\n\n  /**\n   * Returns the value of the `averageCenter` property.\n   *\n   * @return True if averageCenter property is set.\n   */\n  getAverageCenter(): boolean {\n    return this.averageCenter_;\n  }\n\n  /**\n   *  Sets the value of the `averageCenter` property.\n   *\n   *  @param averageCenter The value of the averageCenter property.\n   */\n  setAverageCenter(averageCenter: boolean): void {\n    this.averageCenter_ = averageCenter;\n  }\n\n  /**\n   * Returns the value of the `ignoreHidden` property.\n   *\n   * @return True if ignoreHidden property is set.\n   */\n  getIgnoreHidden(): boolean {\n    return this.ignoreHidden_;\n  }\n\n  /**\n   *  Sets the value of the `ignoreHidden` property.\n   *\n   *  @param ignoreHidden The value of the ignoreHidden property.\n   */\n  setIgnoreHidden(ignoreHidden: boolean): void {\n    this.ignoreHidden_ = ignoreHidden;\n  }\n\n  /**\n   * Returns the value of the `enableRetinaIcons` property.\n   *\n   * @return True if enableRetinaIcons property is set.\n   */\n  getEnableRetinaIcons(): boolean {\n    return this.enableRetinaIcons_;\n  }\n\n  /**\n   *  Sets the value of the `enableRetinaIcons` property.\n   *\n   *  @param enableRetinaIcons The value of the enableRetinaIcons property.\n   */\n  setEnableRetinaIcons(enableRetinaIcons: boolean): void {\n    this.enableRetinaIcons_ = enableRetinaIcons;\n  }\n\n  /**\n   * Returns the value of the `imageExtension` property.\n   *\n   * @return The value of the imageExtension property.\n   */\n  getImageExtension(): string {\n    return this.imageExtension_;\n  }\n\n  /**\n   *  Sets the value of the `imageExtension` property.\n   *\n   *  @param imageExtension The value of the imageExtension property.\n   */\n  setImageExtension(imageExtension: string): void {\n    this.imageExtension_ = imageExtension;\n  }\n\n  /**\n   * Returns the value of the `imagePath` property.\n   *\n   * @return The value of the imagePath property.\n   */\n  getImagePath(): string {\n    return this.imagePath_;\n  }\n\n  /**\n   *  Sets the value of the `imagePath` property.\n   *\n   *  @param imagePath The value of the imagePath property.\n   */\n  setImagePath(imagePath: string): void {\n    this.imagePath_ = imagePath;\n  }\n\n  /**\n   * Returns the value of the `imageSizes` property.\n   *\n   * @return The value of the imageSizes property.\n   */\n  getImageSizes(): number[] {\n    return this.imageSizes_;\n  }\n\n  /**\n   *  Sets the value of the `imageSizes` property.\n   *\n   *  @param imageSizes The value of the imageSizes property.\n   */\n  setImageSizes(imageSizes: number[]): void {\n    this.imageSizes_ = imageSizes;\n  }\n\n  /**\n   * Returns the value of the `calculator` property.\n   *\n   * @return the value of the calculator property.\n   */\n  getCalculator(): Calculator {\n    return this.calculator_;\n  }\n\n  /**\n   * Sets the value of the `calculator` property.\n   *\n   * @param calculator The value of the calculator property.\n   */\n  setCalculator(calculator: Calculator): void {\n    this.calculator_ = calculator;\n  }\n\n  /**\n   * Returns the value of the `batchSizeIE` property.\n   *\n   * @return the value of the batchSizeIE property.\n   */\n  getBatchSizeIE(): number {\n    return this.batchSizeIE_;\n  }\n\n  /**\n   * Sets the value of the `batchSizeIE` property.\n   *\n   *  @param batchSizeIE The value of the batchSizeIE property.\n   */\n  setBatchSizeIE(batchSizeIE: number): void {\n    this.batchSizeIE_ = batchSizeIE;\n  }\n\n  /**\n   * Returns the value of the `clusterClass` property.\n   *\n   * @return the value of the clusterClass property.\n   */\n  getClusterClass(): string {\n    return this.clusterClass_;\n  }\n\n  /**\n   * Sets the value of the `clusterClass` property.\n   *\n   *  @param clusterClass The value of the clusterClass property.\n   */\n  setClusterClass(clusterClass: string): void {\n    this.clusterClass_ = clusterClass;\n  }\n\n  /**\n   *  Returns the array of markers managed by the clusterer.\n   *\n   *  @return The array of markers managed by the clusterer.\n   */\n  getMarkers(): google.maps.Marker[] {\n    return this.markers_;\n  }\n\n  /**\n   *  Returns the number of markers managed by the clusterer.\n   *\n   *  @return The number of markers.\n   */\n  getTotalMarkers(): number {\n    return this.markers_.length;\n  }\n\n  /**\n   * Returns the current array of clusters formed by the clusterer.\n   *\n   * @return The array of clusters formed by the clusterer.\n   */\n  getClusters(): Cluster[] {\n    return this.clusters_;\n  }\n\n  /**\n   * Returns the number of clusters formed by the clusterer.\n   *\n   * @return The number of clusters formed by the clusterer.\n   */\n  getTotalClusters(): number {\n    return this.clusters_.length;\n  }\n\n  /**\n   * Adds a marker to the clusterer. The clusters are redrawn unless\n   *  `nodraw` is set to `true`.\n   *\n   * @param marker The marker to add.\n   * @param nodraw Set to `true` to prevent redrawing.\n   */\n  addMarker(marker: google.maps.Marker, nodraw?: boolean): void {\n    this.pushMarkerTo_(marker);\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n\n  /**\n   * Adds an array of markers to the clusterer. The clusters are redrawn unless\n   *  `nodraw` is set to `true`.\n   *\n   * @param markers The markers to add.\n   * @param nodraw Set to `true` to prevent redrawing.\n   */\n  addMarkers(markers: google.maps.Marker[], nodraw?: boolean): void {\n    for (const key in markers) {\n      if (Object.prototype.hasOwnProperty.call(markers, key)) {\n        this.pushMarkerTo_(markers[key]);\n      }\n    }\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n\n  /**\n   * Pushes a marker to the clusterer.\n   *\n   * @param marker The marker to add.\n   */\n  private pushMarkerTo_(\n    marker: google.maps.Marker & { isAdded?: boolean }\n  ): void {\n    // If the marker is draggable add a listener so we can update the clusters on the dragend:\n    if (marker.getDraggable()) {\n      google.maps.event.addListener(marker, \"dragend\", () => {\n        if (this.ready_) {\n          marker.isAdded = false;\n          this.repaint();\n        }\n      });\n    }\n    marker.isAdded = false;\n    this.markers_.push(marker);\n  }\n\n  /**\n   * Removes a marker from the cluster.  The clusters are redrawn unless\n   *  `nodraw` is set to `true`. Returns `true` if the\n   *  marker was removed from the clusterer.\n   *\n   * @param marker The marker to remove.\n   * @param nodraw Set to `true` to prevent redrawing.\n   * @return True if the marker was removed from the clusterer.\n   */\n  removeMarker(marker: google.maps.Marker, nodraw?: boolean): boolean {\n    const removed = this.removeMarker_(marker);\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Removes an array of markers from the cluster. The clusters are redrawn unless\n   *  `nodraw` is set to `true`. Returns `true` if markers were removed from the clusterer.\n   *\n   * @param markers The markers to remove.\n   * @param nodraw Set to `true` to prevent redrawing.\n   * @return True if markers were removed from the clusterer.\n   */\n  removeMarkers(markers: google.maps.Marker[], nodraw?: boolean): boolean {\n    let removed = false;\n\n    for (let i = 0; i < markers.length; i++) {\n      const r = this.removeMarker_(markers[i]);\n      removed = removed || r;\n    }\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Removes a marker and returns true if removed, false if not.\n   *\n   * @param marker The marker to remove\n   * @return Whether the marker was removed or not\n   */\n  private removeMarker_(marker: google.maps.Marker): boolean {\n    let index = -1;\n    if (this.markers_.indexOf) {\n      index = this.markers_.indexOf(marker);\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers_.splice(index, 1); // Remove the marker from the list of managed markers\n    return true;\n  }\n\n  /**\n   * Removes all clusters and markers from the map and also removes all markers\n   *  managed by the clusterer.\n   */\n  clearMarkers(): void {\n    this.resetViewport_(true);\n    this.markers_ = [];\n  }\n\n  /**\n   * Recalculates and redraws all the marker clusters from scratch.\n   *  Call this after changing any properties.\n   */\n  repaint(): void {\n    const oldClusters = this.clusters_.slice();\n    this.clusters_ = [];\n    this.resetViewport_(false);\n    this.redraw_();\n\n    // Remove the old clusters.\n    // Do it in a timeout to prevent blinking effect.\n    setTimeout(function() {\n      for (let i = 0; i < oldClusters.length; i++) {\n        oldClusters[i].remove();\n      }\n    }, 0);\n  }\n\n  /**\n   * Returns the current bounds extended by the grid size.\n   *\n   * @param bounds The bounds to extend.\n   * @return The extended bounds.\n   * @ignore\n   */\n  getExtendedBounds(\n    bounds: google.maps.LatLngBounds\n  ): google.maps.LatLngBounds {\n    const projection = this.getProjection();\n\n    // Turn the bounds into latlng.\n    const tr = new google.maps.LatLng(\n      bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng()\n    );\n    const bl = new google.maps.LatLng(\n      bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng()\n    );\n\n    // Convert the points to pixels and the extend out by the grid size.\n    const trPix = projection.fromLatLngToDivPixel(tr);\n    trPix.x += this.gridSize_;\n    trPix.y -= this.gridSize_;\n\n    const blPix = projection.fromLatLngToDivPixel(bl);\n    blPix.x -= this.gridSize_;\n    blPix.y += this.gridSize_;\n\n    // Convert the pixel points back to LatLng\n    const ne = projection.fromDivPixelToLatLng(trPix);\n    const sw = projection.fromDivPixelToLatLng(blPix);\n\n    // Extend the bounds to contain the new bounds.\n    bounds.extend(ne);\n    bounds.extend(sw);\n\n    return bounds;\n  }\n\n  /**\n   * Redraws all the clusters.\n   */\n  private redraw_(): void {\n    this.createClusters_(0);\n  }\n\n  /**\n   * Removes all clusters from the map. The markers are also removed from the map\n   *  if `hide` is set to `true`.\n   *\n   * @param hide Set to `true` to also remove the markers from the map.\n   */\n  private resetViewport_(hide?: boolean): void {\n    // Remove all the clusters\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n    this.clusters_ = [];\n\n    // Reset the markers to not be added and to be removed from the map.\n    for (let i = 0; i < this.markers_.length; i++) {\n      const marker = this.markers_[i];\n      marker.isAdded = false;\n      if (hide) {\n        marker.setMap(null);\n      }\n    }\n  }\n\n  /**\n   * Calculates the distance between two latlng locations in km.\n   *\n   * @param p1 The first lat lng point.\n   * @param p2 The second lat lng point.\n   * @return The distance between the two points in km.\n   * @link http://www.movable-type.co.uk/scripts/latlong.html\n   */\n  private distanceBetweenPoints_(\n    p1: google.maps.LatLng,\n    p2: google.maps.LatLng\n  ): number {\n    const R = 6371; // Radius of the Earth in km\n    const dLat = ((p2.lat() - p1.lat()) * Math.PI) / 180;\n    const dLon = ((p2.lng() - p1.lng()) * Math.PI) / 180;\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos((p1.lat() * Math.PI) / 180) *\n        Math.cos((p2.lat() * Math.PI) / 180) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Determines if a marker is contained in a bounds.\n   *\n   * @param marker The marker to check.\n   * @param bounds The bounds to check against.\n   * @return True if the marker is in the bounds.\n   */\n  private isMarkerInBounds_(\n    marker: google.maps.Marker,\n    bounds: google.maps.LatLngBounds\n  ): boolean {\n    return bounds.contains(marker.getPosition());\n  }\n\n  /**\n   * Adds a marker to a cluster, or creates a new cluster.\n   *\n   * @param marker The marker to add.\n   */\n  private addToClosestCluster_(marker: google.maps.Marker): void {\n    let distance = 40000; // Some large number\n    let clusterToAddTo = null;\n    for (let i = 0; i < this.clusters_.length; i++) {\n      const cluster = this.clusters_[i];\n      const center = cluster.getCenter();\n      if (center) {\n        const d = this.distanceBetweenPoints_(center, marker.getPosition());\n        if (d < distance) {\n          distance = d;\n          clusterToAddTo = cluster;\n        }\n      }\n    }\n\n    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n      clusterToAddTo.addMarker(marker);\n    } else {\n      const cluster = new Cluster(this);\n      cluster.addMarker(marker);\n      this.clusters_.push(cluster);\n    }\n  }\n\n  /**\n   * Creates the clusters. This is done in batches to avoid timeout errors\n   *  in some browsers when there is a huge number of markers.\n   *\n   * @param iFirst The index of the first marker in the batch of\n   *  markers to be added to clusters.\n   */\n  private createClusters_(iFirst: number): void {\n    if (!this.ready_) {\n      return;\n    }\n\n    // Cancel previous batch processing if we're working on the first batch:\n    if (iFirst === 0) {\n      google.maps.event.trigger(this, \"clusteringbegin\", this);\n\n      if (typeof this.timerRefStatic !== \"undefined\") {\n        clearTimeout(this.timerRefStatic);\n        delete this.timerRefStatic;\n      }\n    }\n\n    // Get our current map view bounds.\n    // Create a new bounds object so we don't affect the map.\n    //\n    // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n    let mapBounds: google.maps.LatLngBounds;\n\n    if (this.getMap().getZoom() > 3) {\n      mapBounds = new google.maps.LatLngBounds(\n        (this.getMap() as google.maps.Map).getBounds().getSouthWest(),\n        (this.getMap() as google.maps.Map).getBounds().getNorthEast()\n      );\n    } else {\n      mapBounds = new google.maps.LatLngBounds(\n        new google.maps.LatLng(85.02070771743472, -178.48388434375),\n        new google.maps.LatLng(-85.08136444384544, 178.00048865625)\n      );\n    }\n    const bounds = this.getExtendedBounds(mapBounds);\n\n    const iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);\n\n    for (let i = iFirst; i < iLast; i++) {\n      const marker = this.markers_[i];\n      if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n        if (\n          !this.ignoreHidden_ ||\n          (this.ignoreHidden_ && marker.getVisible())\n        ) {\n          this.addToClosestCluster_(marker);\n        }\n      }\n    }\n\n    if (iLast < this.markers_.length) {\n      this.timerRefStatic = window.setTimeout(() => {\n        this.createClusters_(iLast);\n      }, 0);\n    } else {\n      delete this.timerRefStatic;\n      google.maps.event.trigger(this, \"clusteringend\", this);\n\n      for (let i = 0; i < this.clusters_.length; i++) {\n        this.clusters_[i].updateIcon();\n      }\n    }\n  }\n\n  /**\n   * The default function for determining the label text and style\n   * for a cluster icon.\n   *\n   * @param markers The array of markers represented by the cluster.\n   * @param numStyles The number of marker styles available.\n   * @return The information resource for the cluster.\n   */\n  static CALCULATOR(\n    markers: google.maps.Marker[],\n    numStyles: number\n  ): ClusterIconInfo {\n    let index = 0;\n    const count: number = markers.length;\n\n    let dv = count;\n    while (dv !== 0) {\n      dv = Math.floor(dv / 10);\n      index++;\n    }\n\n    index = Math.min(index, numStyles);\n    return {\n      text: count.toString(),\n      index: index,\n      title: \"\"\n    };\n  }\n\n  /**\n   * Generates default styles augmented with user passed values.\n   * Useful when you want to override some default values but keep untouched\n   *\n   * @param overrides override default values\n   */\n  static withDefaultStyle(overrides: ClusterIconStyle): ClusterIconStyle {\n    return {\n      textColor: \"black\",\n      textSize: 11,\n      textDecoration: \"none\",\n      textLineHeight: overrides.height,\n      fontWeight: \"bold\",\n      fontStyle: \"normal\",\n      fontFamily: \"Arial,sans-serif\",\n      backgroundPosition: \"0 0\",\n      ...overrides\n    };\n  }\n}\n"],"names":["OverlayViewSafe","type1","type2","property","prototype","extend","google","maps","OverlayView","toCssText","styles","Object","keys","reduce","acc","key","push","join","coercePixels","pixels","undefined","ClusterIcon","cluster_","styles_","setMap","getMap","cMouseDownInCluster","cDraggingMapByCluster","mc","this","getMarkerClusterer","version","split","major","minor","gmVersion","parseInt","div_","document","createElement","visible_","show","getPanes","overlayMouseTarget","appendChild","boundsChangedListener_","event","addListener","addDomListener","e","stopPropagation","trigger","_this2","getZoomOnClick","mz","getMaxZoom","theBounds","getBounds","fitBounds","setTimeout","getZoom","setZoom","cancelBubble","parentNode","hide","removeListener","clearInstanceListeners","removeChild","pos","getPosFromLatLng_","center_","style","top","y","left","x","display","className","className_","cssText","createCss_","innerHTML","url","getImageElementHtml","getLabelDivHtml","sums_","title","getTitle","ariaLabel","ariaLabelFn","text","divStyle","position","anchorText_","color","textColor","textSize","fontFamily","fontWeight","fontStyle","textDecoration","width","textLineHeight","bp","backgroundPosition","spriteH","replace","spriteV","dimensions","getEnableRetinaIcons","height","Y1","X1","Y2","X2","clip","sums","index","Math","max","min","length","anchorText","anchorIcon_","anchorIcon","floor","getClusterClass","center","getZIndex","cursor","latlng","getProjection","fromLatLngToDivPixel","Cluster","markerClusterer_","getMinimumClusterSize","getAverageCenter","getStyles","markers_","map_","bounds","LatLngBounds","markers","getMarkers","i","getPosition","clusterIcon_","marker","isMarkerAlreadyAdded_","averageCenter_","l","lat","lng","LatLng","calculateBounds_","isAdded","mCount","minClusterSize_","bounds_","contains","getExtendedBounds","numStyles","getCalculator","setCenter","useStyle","indexOf","getOption","options","prop","def","MarkerClusterer","map","_this","zIndex","Marker","MAX_ZINDEX","gridSize","minimumClusterSize","maxZoom","imagePath","IMAGE_PATH","imageExtension","IMAGE_EXTENSION","imageSizes","IMAGE_SIZES","calculator","CALCULATOR","batchSize","BATCH_SIZE","batchSizeIE","BATCH_SIZE_IE","clusterClass","navigator","userAgent","toLowerCase","batchSize_","batchSizeIE_","setupStyles_","addMarkers","activeMap_","ready_","repaint","prevZoom_","listeners_","minZoom","mapTypes","getMapTypeId","zoom","resetViewport_","redraw_","clusters_","remove","imageSizes_","size","withDefaultStyle","imagePath_","imageExtension_","getVisible","getIgnoreHidden","gridSize_","maxZoom_","zIndex_","title_","zoomOnClick_","zoomOnClick","averageCenter","ignoreHidden_","ignoreHidden","enableRetinaIcons_","enableRetinaIcons","calculator_","clusterClass_","nodraw","pushMarkerTo_","hasOwnProperty","call","getDraggable","_this3","removed","removeMarker_","r","splice","oldClusters","slice","projection","tr","getNorthEast","bl","getSouthWest","trPix","blPix","ne","fromDivPixelToLatLng","sw","createClusters_","p1","p2","dLat","PI","dLon","a","sin","cos","atan2","sqrt","distance","clusterToAddTo","cluster","getCenter","d","distanceBetweenPoints_","isMarkerInClusterBounds","addMarker","iFirst","mapBounds","timerRefStatic","clearTimeout","iLast","isMarkerInBounds_","addToClosestCluster_","window","_this4","updateIcon","count","dv","toString","overrides"],"mappings":"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"}